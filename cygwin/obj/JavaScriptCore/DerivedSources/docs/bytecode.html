<style>p code { font-size: 14px; }</style>
<h2><code>new_object</code></h2>
<p><b>Format: </b><code>
new_object dst(r)
</code></p>
<p>

            Constructs a new empty Object instance using the original
            constructor, and puts the result in register dst.
 
</p>
<h2><code>new_array</code></h2>
<p><b>Format: </b><code>
new_array dst(r) firstArg(r) argCount(n)
</code></p>
<p>

            Constructs a new Array instance using the original
            constructor, and puts the result in register dst.
            The array will contain argCount elements with values
            taken from registers starting at register firstArg.
 
</p>
<h2><code>new_regexp</code></h2>
<p><b>Format: </b><code>
new_regexp dst(r) regExp(re)
</code></p>
<p>

            Constructs a new RegExp instance using the original
            constructor from regexp regExp, and puts the result in
            register dst.
 
</p>
<h2><code>mov</code></h2>
<p><b>Format: </b><code>
mov dst(r) src(r)
</code></p>
<p>

            Copies register src to register dst.
 
</p>
<h2><code>eq</code></h2>
<p><b>Format: </b><code>
eq dst(r) src1(r) src2(r)
</code></p>
<p>

            Checks whether register src1 and register src2 are equal,
            as with the ECMAScript '==' operator, and puts the result
            as a boolean in register dst.
 
</p>
<h2><code>eq_null</code></h2>
<p><b>Format: </b><code>
eq_null dst(r) src(r)
</code></p>
<p>

            Checks whether register src is null, as with the ECMAScript '!='
            operator, and puts the result as a boolean in register dst.
 
</p>
<h2><code>neq</code></h2>
<p><b>Format: </b><code>
neq dst(r) src1(r) src2(r)
</code></p>
<p>

            Checks whether register src1 and register src2 are not
            equal, as with the ECMAScript '!=' operator, and puts the
            result as a boolean in register dst.
 
</p>
<h2><code>neq_null</code></h2>
<p><b>Format: </b><code>
neq_null dst(r) src(r)
</code></p>
<p>

            Checks whether register src is not null, as with the ECMAScript '!='
            operator, and puts the result as a boolean in register dst.
 
</p>
<h2><code>stricteq</code></h2>
<p><b>Format: </b><code>
stricteq dst(r) src1(r) src2(r)
</code></p>
<p>

            Checks whether register src1 and register src2 are strictly
            equal, as with the ECMAScript '===' operator, and puts the
            result as a boolean in register dst.
 
</p>
<h2><code>nstricteq</code></h2>
<p><b>Format: </b><code>
nstricteq dst(r) src1(r) src2(r)
</code></p>
<p>

            Checks whether register src1 and register src2 are not
            strictly equal, as with the ECMAScript '!==' operator, and
            puts the result as a boolean in register dst.
 
</p>
<h2><code>less</code></h2>
<p><b>Format: </b><code>
less dst(r) src1(r) src2(r)
</code></p>
<p>

            Checks whether register src1 is less than register src2, as
            with the ECMAScript '<' operator, and puts the result as
            a boolean in register dst.
 
</p>
<h2><code>lesseq</code></h2>
<p><b>Format: </b><code>
lesseq dst(r) src1(r) src2(r)
</code></p>
<p>

            Checks whether register src1 is less than or equal to
            register src2, as with the ECMAScript '<=' operator, and
            puts the result as a boolean in register dst.
 
</p>
<h2><code>pre_inc</code></h2>
<p><b>Format: </b><code>
pre_inc srcDst(r)
</code></p>
<p>

            Converts register srcDst to number, adds one, and puts the result
            back in register srcDst.
 
</p>
<h2><code>pre_dec</code></h2>
<p><b>Format: </b><code>
pre_dec srcDst(r)
</code></p>
<p>

            Converts register srcDst to number, subtracts one, and puts the result
            back in register srcDst.
 
</p>
<h2><code>post_inc</code></h2>
<p><b>Format: </b><code>
post_inc dst(r) srcDst(r)
</code></p>
<p>

            Converts register srcDst to number. The number itself is
            written to register dst, and the number plus one is written
            back to register srcDst.
 
</p>
<h2><code>post_dec</code></h2>
<p><b>Format: </b><code>
post_dec dst(r) srcDst(r)
</code></p>
<p>

            Converts register srcDst to number. The number itself is
            written to register dst, and the number minus one is written
            back to register srcDst.
 
</p>
<h2><code>to_jsnumber</code></h2>
<p><b>Format: </b><code>
to_jsnumber dst(r) src(r)
</code></p>
<p>

            Converts register src to number, and puts the result
            in register dst.
 
</p>
<h2><code>negate</code></h2>
<p><b>Format: </b><code>
negate dst(r) src(r)
</code></p>
<p>

            Converts register src to number, negates it, and puts the
            result in register dst.
 
</p>
<h2><code>add</code></h2>
<p><b>Format: </b><code>
add dst(r) src1(r) src2(r)
</code></p>
<p>

            Adds register src1 and register src2, and puts the result
            in register dst. (JS add may be string concatenation or
            numeric add, depending on the types of the operands.)
 
</p>
<h2><code>mul</code></h2>
<p><b>Format: </b><code>
mul dst(r) src1(r) src2(r)
</code></p>
<p>

            Multiplies register src1 and register src2 (converted to
            numbers), and puts the product in register dst.
 
</p>
<h2><code>div</code></h2>
<p><b>Format: </b><code>
div dst(r) dividend(r) divisor(r)
</code></p>
<p>

            Divides register dividend (converted to number) by the
            register divisor (converted to number), and puts the
            quotient in register dst.
 
</p>
<h2><code>mod</code></h2>
<p><b>Format: </b><code>
mod dst(r) dividend(r) divisor(r)
</code></p>
<p>

            Divides register dividend (converted to number) by
            register divisor (converted to number), and puts the
            remainder in register dst.
 
</p>
<h2><code>sub</code></h2>
<p><b>Format: </b><code>
sub dst(r) src1(r) src2(r)
</code></p>
<p>

            Subtracts register src2 (converted to number) from register
            src1 (converted to number), and puts the difference in
            register dst.
 
</p>
<h2><code>lshift</code></h2>
<p><b>Format: </b><code>
lshift dst(r) val(r) shift(r)
</code></p>
<p>

            Performs left shift of register val (converted to int32) by
            register shift (converted to uint32), and puts the result
            in register dst.
 
</p>
<h2><code>rshift</code></h2>
<p><b>Format: </b><code>
rshift dst(r) val(r) shift(r)
</code></p>
<p>

            Performs arithmetic right shift of register val (converted
            to int32) by register shift (converted to
            uint32), and puts the result in register dst.
 
</p>
<h2><code>urshift</code></h2>
<p><b>Format: </b><code>
rshift dst(r) val(r) shift(r)
</code></p>
<p>

            Performs logical right shift of register val (converted
            to uint32) by register shift (converted to
            uint32), and puts the result in register dst.
 
</p>
<h2><code>bitand</code></h2>
<p><b>Format: </b><code>
bitand dst(r) src1(r) src2(r)
</code></p>
<p>

            Computes bitwise AND of register src1 (converted to int32)
            and register src2 (converted to int32), and puts the result
            in register dst.
 
</p>
<h2><code>bitxor</code></h2>
<p><b>Format: </b><code>
bitxor dst(r) src1(r) src2(r)
</code></p>
<p>

            Computes bitwise XOR of register src1 (converted to int32)
            and register src2 (converted to int32), and puts the result
            in register dst.
 
</p>
<h2><code>bitor</code></h2>
<p><b>Format: </b><code>
bitor dst(r) src1(r) src2(r)
</code></p>
<p>

            Computes bitwise OR of register src1 (converted to int32)
            and register src2 (converted to int32), and puts the
            result in register dst.
 
</p>
<h2><code>bitnot</code></h2>
<p><b>Format: </b><code>
bitnot dst(r) src(r)
</code></p>
<p>

            Computes bitwise NOT of register src1 (converted to int32),
            and puts the result in register dst.
 
</p>
<h2><code>not</code></h2>
<p><b>Format: </b><code>
not dst(r) src(r)
</code></p>
<p>

            Computes logical NOT of register src (converted to
            boolean), and puts the result in register dst.
 
</p>
<h2><code>instanceof</code></h2>
<p><b>Format: </b><code>
instanceof dst(r) value(r) constructor(r) constructorProto(r)
</code></p>
<p>

            Tests whether register value is an instance of register
            constructor, and puts the boolean result in register
            dst. Register constructorProto must contain the "prototype"
            property (not the actual prototype) of the object in
            register constructor. This lookup is separated so that
            polymorphic inline caching can apply.
 
            Raises an exception if register constructor is not an
            object.
 
</p>
<h2><code>typeof</code></h2>
<p><b>Format: </b><code>
typeof dst(r) src(r)
</code></p>
<p>

            Determines the type string for src according to ECMAScript
            rules, and puts the result in register dst.
 
</p>
<h2><code>is_undefined</code></h2>
<p><b>Format: </b><code>
is_undefined dst(r) src(r)
</code></p>
<p>

            Determines whether the type string for src according to
            the ECMAScript rules is "undefined", and puts the result
            in register dst.
 
</p>
<h2><code>is_boolean</code></h2>
<p><b>Format: </b><code>
is_boolean dst(r) src(r)
</code></p>
<p>

            Determines whether the type string for src according to
            the ECMAScript rules is "boolean", and puts the result
            in register dst.
 
</p>
<h2><code>is_number</code></h2>
<p><b>Format: </b><code>
is_number dst(r) src(r)
</code></p>
<p>

            Determines whether the type string for src according to
            the ECMAScript rules is "number", and puts the result
            in register dst.
 
</p>
<h2><code>is_string</code></h2>
<p><b>Format: </b><code>
is_string dst(r) src(r)
</code></p>
<p>

            Determines whether the type string for src according to
            the ECMAScript rules is "string", and puts the result
            in register dst.
 
</p>
<h2><code>is_object</code></h2>
<p><b>Format: </b><code>
is_object dst(r) src(r)
</code></p>
<p>

            Determines whether the type string for src according to
            the ECMAScript rules is "object", and puts the result
            in register dst.
 
</p>
<h2><code>is_function</code></h2>
<p><b>Format: </b><code>
is_function dst(r) src(r)
</code></p>
<p>

            Determines whether the type string for src according to
            the ECMAScript rules is "function", and puts the result
            in register dst.
 
</p>
<h2><code>in</code></h2>
<p><b>Format: </b><code>
in dst(r) property(r) base(r)
</code></p>
<p>

            Tests whether register base has a property named register
            property, and puts the boolean result in register dst.
 
            Raises an exception if register constructor is not an
            object.
 
</p>
<h2><code>resolve</code></h2>
<p><b>Format: </b><code>
resolve dst(r) property(id)
</code></p>
<p>

            Looks up the property named by identifier property in the
            scope chain, and writes the resulting value to register
            dst. If the property is not found, raises an exception.
 
</p>
<h2><code>resolve_skip</code></h2>
<p><b>Format: </b><code>
resolve_skip dst(r) property(id) skip(n)
</code></p>
<p>

          Looks up the property named by identifier property in the
          scope chain skipping the top 'skip' levels, and writes the resulting
          value to register dst. If the property is not found, raises an exception.
 
</p>
<h2><code>resolve_global</code></h2>
<p><b>Format: </b><code>
resolve_skip dst(r) globalObject(c) property(id) structure(sID) offset(n)
</code></p>
<p>
         
            Performs a dynamic property lookup for the given property, on the provided
            global object.  If structure matches the Structure of the global then perform
            a fast lookup using the case offset, otherwise fall back to a full resolve and
            cache the new structure and offset
 
</p>
<h2><code>resolve_global_dynamic</code></h2>
<p><b>Format: </b><code>
resolve_skip dst(r) globalObject(c) property(id) structure(sID) offset(n), depth(n)
</code></p>
<p>
         
          Performs a dynamic property lookup for the given property, on the provided
          global object.  If structure matches the Structure of the global then perform
          a fast lookup using the case offset, otherwise fall back to a full resolve and
          cache the new structure and offset.
          
          This walks through n levels of the scope chain to verify that none of those levels
          in the scope chain include dynamically added properties.
 
</p>
<h2><code>get_global_var</code></h2>
<p><b>Format: </b><code>
get_global_var dst(r) globalObject(c) index(n)
</code></p>
<p>

            Gets the global var at global slot index and places it in register dst.
 
</p>
<h2><code>put_global_var</code></h2>
<p><b>Format: </b><code>
put_global_var globalObject(c) index(n) value(r)
</code></p>
<p>
         
            Puts value into global slot index.
 
</p>
<h2><code>get_scoped_var</code></h2>
<p><b>Format: </b><code>
get_scoped_var dst(r) index(n) skip(n)
</code></p>
<p>

          Loads the contents of the index-th local from the scope skip nodes from
          the top of the scope chain, and places it in register dst.
 
</p>
<h2><code>put_scoped_var</code></h2>
<p><b>Format: </b><code>
put_scoped_var index(n) skip(n) value(r)
</code></p>
<p>

 
</p>
<h2><code>resolve_base</code></h2>
<p><b>Format: </b><code>
resolve_base dst(r) property(id)
</code></p>
<p>

            Searches the scope chain for an object containing
            identifier property, and if one is found, writes it to
            register dst. If none is found, the outermost scope (which
            will be the global object) is stored in register dst.
 
</p>
<h2><code>resolve_with_base</code></h2>
<p><b>Format: </b><code>
resolve_with_base baseDst(r) propDst(r) property(id)
</code></p>
<p>

            Searches the scope chain for an object containing
            identifier property, and if one is found, writes it to
            register srcDst, and the retrieved property value to register
            propDst. If the property is not found, raises an exception.
 
            This is more efficient than doing resolve_base followed by
            resolve, or resolve_base followed by get_by_id, as it
            avoids duplicate hash lookups.
 
</p>
<h2><code>get_by_id</code></h2>
<p><b>Format: </b><code>
get_by_id dst(r) base(r) property(id) structure(sID) nop(n) nop(n) nop(n)
</code></p>
<p>

            Generic property access: Gets the property named by identifier
            property from the value base, and puts the result in register dst.
 
</p>
<h2><code>get_by_id_self</code></h2>
<p><b>Format: </b><code>
op_get_by_id_self dst(r) base(r) property(id) structure(sID) offset(n) nop(n) nop(n)
</code></p>
<p>

            Cached property access: Attempts to get a cached property from the
            value base. If the cache misses, op_get_by_id_self reverts to
            op_get_by_id.
 
</p>
<h2><code>get_by_id_proto</code></h2>
<p><b>Format: </b><code>
op_get_by_id_proto dst(r) base(r) property(id) structure(sID) prototypeStructure(sID) offset(n) nop(n)
</code></p>
<p>

            Cached property access: Attempts to get a cached property from the
            value base's prototype. If the cache misses, op_get_by_id_proto
            reverts to op_get_by_id.
 
</p>
<h2><code>get_by_id_getter_proto</code></h2>
<p><b>Format: </b><code>
op_get_by_id_getter_proto dst(r) base(r) property(id) structure(sID) prototypeStructure(sID) offset(n) nop(n)
</code></p>
<p>
         
          Cached property access: Attempts to get a cached getter property from the
          value base's prototype. If the cache misses, op_get_by_id_getter_proto
          reverts to op_get_by_id.
 
</p>
<h2><code>get_by_id_custom_proto</code></h2>
<p><b>Format: </b><code>
op_get_by_id_custom_proto dst(r) base(r) property(id) structure(sID) prototypeStructure(sID) offset(n) nop(n)
</code></p>
<p>
         
          Cached property access: Attempts to use a cached named property getter
          from the value base's prototype. If the cache misses, op_get_by_id_custom_proto
          reverts to op_get_by_id.
 
</p>
<h2><code>get_by_id_chain</code></h2>
<p><b>Format: </b><code>
op_get_by_id_chain dst(r) base(r) property(id) structure(sID) structureChain(chain) count(n) offset(n)
</code></p>
<p>

            Cached property access: Attempts to get a cached property from the
            value base's prototype chain. If the cache misses, op_get_by_id_chain
            reverts to op_get_by_id.
 
</p>
<h2><code>get_by_id_getter_self</code></h2>
<p><b>Format: </b><code>
op_get_by_id_self dst(r) base(r) property(id) structure(sID) offset(n) nop(n) nop(n)
</code></p>
<p>
         
          Cached property access: Attempts to get a cached property from the
          value base. If the cache misses, op_get_by_id_getter_self reverts to
          op_get_by_id.
 
</p>
<h2><code>get_by_id_custom_self</code></h2>
<p><b>Format: </b><code>
op_get_by_id_custom_self dst(r) base(r) property(id) structure(sID) offset(n) nop(n) nop(n)
</code></p>
<p>
         
          Cached property access: Attempts to use a cached named property getter
          from the value base. If the cache misses, op_get_by_id_custom_self reverts to
          op_get_by_id.
 
</p>
<h2><code>get_by_id_generic</code></h2>
<p><b>Format: </b><code>
op_get_by_id_generic dst(r) base(r) property(id) nop(sID) nop(n) nop(n) nop(n)
</code></p>
<p>

            Generic property access: Gets the property named by identifier
            property from the value base, and puts the result in register dst.
 
</p>
<h2><code>get_by_id_getter_chain</code></h2>
<p><b>Format: </b><code>
op_get_by_id_getter_chain dst(r) base(r) property(id) structure(sID) structureChain(chain) count(n) offset(n)
</code></p>
<p>
         
          Cached property access: Attempts to get a cached property from the
          value base's prototype chain. If the cache misses, op_get_by_id_getter_chain
          reverts to op_get_by_id.
 
</p>
<h2><code>get_by_id_custom_chain</code></h2>
<p><b>Format: </b><code>
op_get_by_id_custom_chain dst(r) base(r) property(id) structure(sID) structureChain(chain) count(n) offset(n)
</code></p>
<p>
         
          Cached property access: Attempts to use a cached named property getter on the
          value base's prototype chain. If the cache misses, op_get_by_id_custom_chain
          reverts to op_get_by_id.
 
</p>
<h2><code>get_array_length</code></h2>
<p><b>Format: </b><code>
op_get_array_length dst(r) base(r) property(id) nop(sID) nop(n) nop(n) nop(n)
</code></p>
<p>

            Cached property access: Gets the length of the array in register base,
            and puts the result in register dst. If register base does not hold
            an array, op_get_array_length reverts to op_get_by_id.
 
</p>
<h2><code>get_string_length</code></h2>
<p><b>Format: </b><code>
op_get_string_length dst(r) base(r) property(id) nop(sID) nop(n) nop(n) nop(n)
</code></p>
<p>

            Cached property access: Gets the length of the string in register base,
            and puts the result in register dst. If register base does not hold
            a string, op_get_string_length reverts to op_get_by_id.
 
</p>
<h2><code>put_by_id</code></h2>
<p><b>Format: </b><code>
put_by_id base(r) property(id) value(r) nop(n) nop(n) nop(n) nop(n) direct(b)
</code></p>
<p>

            Generic property access: Sets the property named by identifier
            property, belonging to register base, to register value.
 
            Unlike many opcodes, this one does not write any output to
            the register file.
 
            The "direct" flag should only be set this put_by_id is to initialize
            an object literal.
 
</p>
<h2><code>put_by_id_transition</code></h2>
<p><b>Format: </b><code>
op_put_by_id_transition base(r) property(id) value(r) oldStructure(sID) newStructure(sID) structureChain(chain) offset(n) direct(b)
</code></p>
<p>
         
            Cached property access: Attempts to set a new property with a cached transition
            property named by identifier property, belonging to register base,
            to register value. If the cache misses, op_put_by_id_transition
            reverts to op_put_by_id_generic.
          
            Unlike many opcodes, this one does not write any output to
            the register file.
 
</p>
<h2><code>put_by_id_replace</code></h2>
<p><b>Format: </b><code>
op_put_by_id_replace base(r) property(id) value(r) structure(sID) offset(n) nop(n) nop(n) direct(b)
</code></p>
<p>

            Cached property access: Attempts to set a pre-existing, cached
            property named by identifier property, belonging to register base,
            to register value. If the cache misses, op_put_by_id_replace
            reverts to op_put_by_id.
 
            Unlike many opcodes, this one does not write any output to
            the register file.
 
</p>
<h2><code>put_by_id_generic</code></h2>
<p><b>Format: </b><code>
op_put_by_id_generic base(r) property(id) value(r) nop(n) nop(n) nop(n) nop(n) direct(b)
</code></p>
<p>

            Generic property access: Sets the property named by identifier
            property, belonging to register base, to register value.
 
            Unlike many opcodes, this one does not write any output to
            the register file.
 
</p>
<h2><code>del_by_id</code></h2>
<p><b>Format: </b><code>
del_by_id dst(r) base(r) property(id)
</code></p>
<p>

            Converts register base to Object, deletes the property
            named by identifier property from the object, and writes a
            boolean indicating success (if true) or failure (if false)
            to register dst.
 
</p>
<h2><code>get_by_val</code></h2>
<p><b>Format: </b><code>
get_by_val dst(r) base(r) property(r)
</code></p>
<p>

            Converts register base to Object, gets the property named
            by register property from the object, and puts the result
            in register dst. property is nominally converted to string
            but numbers are treated more efficiently.
 
</p>
<h2><code>put_by_val</code></h2>
<p><b>Format: </b><code>
put_by_val base(r) property(r) value(r)
</code></p>
<p>

            Sets register value on register base as the property named
            by register property. Base is converted to object
            first. register property is nominally converted to string
            but numbers are treated more efficiently.
 
            Unlike many opcodes, this one does not write any output to
            the register file.
 
</p>
<h2><code>del_by_val</code></h2>
<p><b>Format: </b><code>
del_by_val dst(r) base(r) property(r)
</code></p>
<p>

            Converts register base to Object, deletes the property
            named by register property from the object, and writes a
            boolean indicating success (if true) or failure (if false)
            to register dst.
 
</p>
<h2><code>put_by_index</code></h2>
<p><b>Format: </b><code>
put_by_index base(r) property(n) value(r)
</code></p>
<p>

            Sets register value on register base as the property named
            by the immediate number property. Base is converted to
            object first.
 
            Unlike many opcodes, this one does not write any output to
            the register file.
 
            This opcode is mainly used to initialize array literals.
 
</p>
<h2><code>loop</code></h2>
<p><b>Format: </b><code>
loop target(offset)
</code></p>
<p>
         
            Jumps unconditionally to offset target from the current
            instruction.
 
            Additionally this loop instruction may terminate JS execution is
            the JS timeout is reached.
 
</p>
<h2><code>jmp</code></h2>
<p><b>Format: </b><code>
jmp target(offset)
</code></p>
<p>

            Jumps unconditionally to offset target from the current
            instruction.
 
</p>
<h2><code>loop_if_true</code></h2>
<p><b>Format: </b><code>
loop_if_true cond(r) target(offset)
</code></p>
<p>
         
            Jumps to offset target from the current instruction, if and
            only if register cond converts to boolean as true.
 
            Additionally this loop instruction may terminate JS execution is
            the JS timeout is reached.
 
</p>
<h2><code>loop_if_false</code></h2>
<p><b>Format: </b><code>
loop_if_true cond(r) target(offset)
</code></p>
<p>
         
            Jumps to offset target from the current instruction, if and
            only if register cond converts to boolean as false.
 
            Additionally this loop instruction may terminate JS execution is
            the JS timeout is reached.
 
</p>
<h2><code>jtrue</code></h2>
<p><b>Format: </b><code>
jtrue cond(r) target(offset)
</code></p>
<p>

            Jumps to offset target from the current instruction, if and
            only if register cond converts to boolean as true.
 
</p>
<h2><code>jfalse</code></h2>
<p><b>Format: </b><code>
jfalse cond(r) target(offset)
</code></p>
<p>

            Jumps to offset target from the current instruction, if and
            only if register cond converts to boolean as false.
 
</p>
<h2><code>jeq_null</code></h2>
<p><b>Format: </b><code>
jeq_null src(r) target(offset)
</code></p>
<p>

            Jumps to offset target from the current instruction, if and
            only if register src is null.
 
</p>
<h2><code>jneq_null</code></h2>
<p><b>Format: </b><code>
jneq_null src(r) target(offset)
</code></p>
<p>

            Jumps to offset target from the current instruction, if and
            only if register src is not null.
 
</p>
<h2><code>jneq_ptr</code></h2>
<p><b>Format: </b><code>
jneq_ptr src(r) ptr(jsCell) target(offset)
</code></p>
<p>
         
            Jumps to offset target from the current instruction, if the value r is equal
            to ptr, using pointer equality.
 
</p>
<h2><code>loop_if_less</code></h2>
<p><b>Format: </b><code>
loop_if_less src1(r) src2(r) target(offset)
</code></p>
<p>

            Checks whether register src1 is less than register src2, as
            with the ECMAScript '<' operator, and then jumps to offset
            target from the current instruction, if and only if the 
            result of the comparison is true.
 
            Additionally this loop instruction may terminate JS execution is
            the JS timeout is reached.
 
</p>
<h2><code>loop_if_lesseq</code></h2>
<p><b>Format: </b><code>
loop_if_lesseq src1(r) src2(r) target(offset)
</code></p>
<p>

            Checks whether register src1 is less than or equal to register
            src2, as with the ECMAScript '<=' operator, and then jumps to
            offset target from the current instruction, if and only if the 
            result of the comparison is true.
 
            Additionally this loop instruction may terminate JS execution is
            the JS timeout is reached.
 
</p>
<h2><code>jnless</code></h2>
<p><b>Format: </b><code>
jnless src1(r) src2(r) target(offset)
</code></p>
<p>

            Checks whether register src1 is less than register src2, as
            with the ECMAScript '<' operator, and then jumps to offset
            target from the current instruction, if and only if the 
            result of the comparison is false.
 
</p>
<h2><code>jless</code></h2>
<p><b>Format: </b><code>
jless src1(r) src2(r) target(offset)
</code></p>
<p>

            Checks whether register src1 is less than register src2, as
            with the ECMAScript '<' operator, and then jumps to offset
            target from the current instruction, if and only if the 
            result of the comparison is true.
 
</p>
<h2><code>jnlesseq</code></h2>
<p><b>Format: </b><code>
jnlesseq src1(r) src2(r) target(offset)
</code></p>
<p>

            Checks whether register src1 is less than or equal to
            register src2, as with the ECMAScript '<=' operator,
            and then jumps to offset target from the current instruction,
            if and only if theresult of the comparison is false.
 
</p>
<h2><code>jlesseq</code></h2>
<p><b>Format: </b><code>
jlesseq src1(r) src2(r) target(offset)
</code></p>
<p>
         
          Checks whether register src1 is less than or equal to
          register src2, as with the ECMAScript '<=' operator,
          and then jumps to offset target from the current instruction,
          if and only if the result of the comparison is true.
 
</p>
<h2><code>switch_imm</code></h2>
<p><b>Format: </b><code>
switch_imm tableIndex(n) defaultOffset(offset) scrutinee(r)
</code></p>
<p>

            Performs a range checked switch on the scrutinee value, using
            the tableIndex-th immediate switch jump table.  If the scrutinee value
            is an immediate number in the range covered by the referenced jump
            table, and the value at jumpTable[scrutinee value] is non-zero, then
            that value is used as the jump offset, otherwise defaultOffset is used.
 
</p>
<h2><code>switch_char</code></h2>
<p><b>Format: </b><code>
switch_char tableIndex(n) defaultOffset(offset) scrutinee(r)
</code></p>
<p>

            Performs a range checked switch on the scrutinee value, using
            the tableIndex-th character switch jump table.  If the scrutinee value
            is a single character string in the range covered by the referenced jump
            table, and the value at jumpTable[scrutinee value] is non-zero, then
            that value is used as the jump offset, otherwise defaultOffset is used.
 
</p>
<h2><code>switch_string</code></h2>
<p><b>Format: </b><code>
switch_string tableIndex(n) defaultOffset(offset) scrutinee(r)
</code></p>
<p>

            Performs a sparse hashmap based switch on the value in the scrutinee
            register, using the tableIndex-th string switch jump table.  If the 
            scrutinee value is a string that exists as a key in the referenced 
            jump table, then the value associated with the string is used as the 
            jump offset, otherwise defaultOffset is used.
 
</p>
<h2><code>new_func</code></h2>
<p><b>Format: </b><code>
new_func dst(r) func(f)
</code></p>
<p>

            Constructs a new Function instance from function func and
            the current scope chain using the original Function
            constructor, using the rules for function declarations, and
            puts the result in register dst.
 
</p>
<h2><code>new_func_exp</code></h2>
<p><b>Format: </b><code>
new_func_exp dst(r) func(f)
</code></p>
<p>

            Constructs a new Function instance from function func and
            the current scope chain using the original Function
            constructor, using the rules for function expressions, and
            puts the result in register dst.
 
</p>
<h2><code>call_eval</code></h2>
<p><b>Format: </b><code>
call_eval func(r) argCount(n) registerOffset(n)
</code></p>
<p>

            Call a function named "eval" with no explicit "this" value
            (which may therefore be the eval operator). If register
            thisVal is the global object, and register func contains
            that global object's original global eval function, then
            perform the eval operator in local scope (interpreting
            the argument registers as for the "call"
            opcode). Otherwise, act exactly as the "call" opcode would.
 
</p>
<h2><code>call</code></h2>
<p><b>Format: </b><code>
call func(r) argCount(n) registerOffset(n)
</code></p>
<p>

            Perform a function call.
            
            registerOffset is the distance the callFrame pointer should move
            before the VM initializes the new call frame's header.
            
            dst is where op_ret should store its result.
 
</p>
<h2><code>call_varargs</code></h2>
<p><b>Format: </b><code>
call_varargs func(r) argCountReg(r) baseRegisterOffset(n)
</code></p>
<p>
         
          Perform a function call with a dynamic set of arguments.
          
          registerOffset is the distance the callFrame pointer should move
          before the VM initializes the new call frame's header, excluding
          space for arguments.
          
          dst is where op_ret should store its result.
 
</p>
<h2><code>tear_off_activation</code></h2>
<p><b>Format: </b><code>
tear_off_activation activation(r) arguments(r)
</code></p>
<p>

            Copy locals and named parameters from the register file to the heap.
            Point the bindings in 'activation' and 'arguments' to this new backing
            store. (Note that 'arguments' may not have been created. If created,
            'arguments' already holds a copy of any extra / unnamed parameters.)
 
            This opcode appears before op_ret in functions that require full scope chains.
 
</p>
<h2><code>tear_off_arguments</code></h2>
<p><b>Format: </b><code>
tear_off_arguments arguments(r)
</code></p>
<p>

            Copy named parameters from the register file to the heap. Point the
            bindings in 'arguments' to this new backing store. (Note that
            'arguments' may not have been created. If created, 'arguments' already
            holds a copy of any extra / unnamed parameters.)
 
            This opcode appears before op_ret in functions that don't require full
            scope chains, but do use 'arguments'.
 
</p>
<h2><code>ret</code></h2>
<p><b>Format: </b><code>
ret result(r)
</code></p>
<p>
           
            Return register result as the return value of the current
            function call, writing it into functionReturnValue.
            In addition, unwind one call frame and restore the scope
            chain, code block instruction pointer and register base
            to those of the calling function.
 
</p>
<h2><code>call_put_result</code></h2>
<p><b>Format: </b><code>
op_call_put_result result(r)
</code></p>
<p>
           
            Move call result from functionReturnValue to caller's
            expected return value register.
 
</p>
<h2><code>ret_object_or_this</code></h2>
<p><b>Format: </b><code>
ret result(r)
</code></p>
<p>
           
            Return register result as the return value of the current
            function call, writing it into the caller's expected return
            value register. In addition, unwind one call frame and
            restore the scope chain, code block instruction pointer and
            register base to those of the calling function.
 
</p>
<h2><code>enter</code></h2>
<p><b>Format: </b><code>
enter
</code></p>
<p>

            Initializes local variables to undefined. If the code block requires
            an activation, enter_with_activation is used instead.
 
            This opcode appears only at the beginning of a code block.
 
</p>
<h2><code>enter_with_activation</code></h2>
<p><b>Format: </b><code>
enter_with_activation dst(r)
</code></p>
<p>

            Initializes local variables to undefined, creates an activation object,
            places it in dst, and pushes it onto the scope chain.
 
            This opcode appears only at the beginning of a code block.
 
</p>
<h2><code>get_callee</code></h2>
<p><b>Format: </b><code>
op_get_callee callee(r)
</code></p>
<p>

            Move callee into a register.
 
</p>
<h2><code>create_this</code></h2>
<p><b>Format: </b><code>
op_create_this this(r) proto(r)
</code></p>
<p>

            Allocate an object as 'this', fr use in construction.
 
            This opcode should only be used at the beginning of a code
            block.
 
</p>
<h2><code>convert_this</code></h2>
<p><b>Format: </b><code>
convert_this this(r)
</code></p>
<p>

            Takes the value in the 'this' register, converts it to a
            value that is suitable for use as the 'this' value, and
            stores it in the 'this' register. This opcode is emitted
            to avoid doing the conversion in the caller unnecessarily.
 
            This opcode should only be used at the beginning of a code
            block.
 
</p>
<h2><code>init_arguments</code></h2>
<p><b>Format: </b><code>
create_arguments dst(r)
</code></p>
<p>

            Initialises 'arguments' to JSValue().
 
            This opcode appears only at the beginning of a code block.
 
</p>
<h2><code>create_arguments</code></h2>
<p><b>Format: </b><code>
create_arguments dst(r)
</code></p>
<p>

            Creates the 'arguments' object and places it in both the
            'arguments' call frame slot and the local 'arguments'
            register, if it has not already been initialised.
 
</p>
<h2><code>construct</code></h2>
<p><b>Format: </b><code>
construct func(r) argCount(n) registerOffset(n) proto(r) thisRegister(r)
</code></p>
<p>

            Invoke register "func" as a constructor. For JS
            functions, the calling convention is exactly as for the
            "call" opcode, except that the "this" value is a newly
            created Object. For native constructors, no "this"
            value is passed. In either case, the argCount and registerOffset
            registers are interpreted as for the "call" opcode.
 
            Register proto must contain the prototype property of
            register func. This is to enable polymorphic inline
            caching of this lookup.
 
</p>
<h2><code>push_scope</code></h2>
<p><b>Format: </b><code>
push_scope scope(r)
</code></p>
<p>

            Converts register scope to object, and pushes it onto the top
            of the current scope chain.  The contents of the register scope
            are replaced by the result of toObject conversion of the scope.
 
</p>
<h2><code>pop_scope</code></h2>
<p><b>Format: </b><code>
pop_scope
</code></p>
<p>

            Removes the top item from the current scope chain.
 
</p>
<h2><code>get_pnames</code></h2>
<p><b>Format: </b><code>
get_pnames dst(r) base(r) i(n) size(n) breakTarget(offset)
</code></p>
<p>

            Creates a property name list for register base and puts it
            in register dst, initializing i and size for iteration. If
            base is undefined or null, jumps to breakTarget.
 
</p>
<h2><code>next_pname</code></h2>
<p><b>Format: </b><code>
next_pname dst(r) base(r) i(n) size(n) iter(r) target(offset)
</code></p>
<p>

            Copies the next name from the property name list in
            register iter to dst, then jumps to offset target. If there are no
            names left, invalidates the iterator and continues to the next
            instruction.
 
</p>
<h2><code>jmp_scopes</code></h2>
<p><b>Format: </b><code>
jmp_scopes count(n) target(offset)
</code></p>
<p>

            Removes the a number of items from the current scope chain
            specified by immediate number count, then jumps to offset
            target.
 
</p>
<h2><code>push_new_scope</code></h2>
<p><b>Format: </b><code>
new_scope dst(r) property(id) value(r)
</code></p>
<p>
         
            Constructs a new StaticScopeObject with property set to value.  That scope
            object is then pushed onto the ScopeChain.  The scope object is then stored
            in dst for GC.
 
</p>
<h2><code>catch</code></h2>
<p><b>Format: </b><code>
catch ex(r)
</code></p>
<p>

            Retrieves the VM's current exception and puts it in register
            ex. This is only valid after an exception has been raised,
            and usually forms the beginning of an exception handler.
 
</p>
<h2><code>throw</code></h2>
<p><b>Format: </b><code>
throw ex(r)
</code></p>
<p>

            Throws register ex as an exception. This involves three
            steps: first, it is set as the current exception in the
            VM's internal state, then the stack is unwound until an
            exception handler or a native code boundary is found, and
            then control resumes at the exception handler if any or
            else the script returns control to the nearest native caller.
 
</p>
<h2><code>new_error</code></h2>
<p><b>Format: </b><code>
new_error dst(r) type(n) message(k)
</code></p>
<p>

            Constructs a new Error instance using the original
            constructor, using immediate number n as the type and
            constant message as the message string. The result is
            written to register dst.
 
</p>
<h2><code>end</code></h2>
<p><b>Format: </b><code>
end result(r)
</code></p>
<p>
           
            Return register result as the value of a global or eval
            program. Return control to the calling native code.
 
</p>
<h2><code>put_getter</code></h2>
<p><b>Format: </b><code>
put_getter base(r) property(id) function(r)
</code></p>
<p>

            Sets register function on register base as the getter named
            by identifier property. Base and function are assumed to be
            objects as this op should only be used for getters defined
            in object literal form.
 
            Unlike many opcodes, this one does not write any output to
            the register file.
 
</p>
<h2><code>put_setter</code></h2>
<p><b>Format: </b><code>
put_setter base(r) property(id) function(r)
</code></p>
<p>

            Sets register function on register base as the setter named
            by identifier property. Base and function are assumed to be
            objects as this op should only be used for setters defined
            in object literal form.
 
            Unlike many opcodes, this one does not write any output to
            the register file.
 
</p>
<h2><code>jsr</code></h2>
<p><b>Format: </b><code>
jsr retAddrDst(r) target(offset)
</code></p>
<p>

            Places the address of the next instruction into the retAddrDst
            register and jumps to offset target from the current instruction.
 
</p>
<h2><code>sret</code></h2>
<p><b>Format: </b><code>
sret retAddrSrc(r)
</code></p>
<p>

          Jumps to the address stored in the retAddrSrc register. This
          differs from op_jmp because the target address is stored in a
          register, not as an immediate.
 
</p>
<h2><code>debug</code></h2>
<p><b>Format: </b><code>
debug debugHookID(n) firstLine(n) lastLine(n)
</code></p>
<p>

          Notifies the debugger of the current state of execution. This opcode
          is only generated while the debugger is attached.
 
</p>
<h2><code>profile_will_call</code></h2>
<p><b>Format: </b><code>
op_profile_will_call function(r)
</code></p>
<p>

          Notifies the profiler of the beginning of a function call. This opcode
          is only generated if developer tools are enabled.
 
</p>
<h2><code>profile_did_call</code></h2>
<p><b>Format: </b><code>
op_profile_did_call function(r)
</code></p>
<p>

          Notifies the profiler of the end of a function call. This opcode
          is only generated if developer tools are enabled.
 
</p>
